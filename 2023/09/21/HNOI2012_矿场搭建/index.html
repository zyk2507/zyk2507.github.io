<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />
  <title>zyk2507 的博客</title>
  <link rel="shortcut icon" href="/images/favicon.ico"> 
<link rel="stylesheet" href="/css/style.css">
 
<script src="/js/jquery.js"></script>
 
<script src="/js/search.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="zyk2507 的博客" type="application/atom+xml">
</head>

<body>
  <article class="article-container">
  <section class="header-container">
  <a class="header-title" href="/">
    <svg t="1693387181307" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4053" width="20" height="20">
      <path d="M946.5 505L560.1 118.8l-25.9-25.9c-12.3-12.2-32.1-12.2-44.4 0L77.5 505c-12.3 12.3-18.9 28.6-18.8 46 0.4 35.2 29.7 63.3 64.9 63.3h42.5V940h691.8V614.3h43.4c17.1 0 33.2-6.7 45.3-18.8 12.1-12.1 18.7-28.2 18.7-45.3 0-17-6.7-33.1-18.8-45.2zM568 868H456V664h112v204z m217.9-325.7V868H632V640c0-22.1-17.9-40-40-40H432c-22.1 0-40 17.9-40 40v228H238.1V542.3h-96l370-369.7 23.1 23.1L882 542.3h-96.1z" p-id="4054" fill="#515151"></path>
    </svg>
    <span>zyk2507 的博客</span>
  </a>
</section>
  <section class="article-body">
    <div class="post-toc">
      <h3>本文目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#HNOI2012-%E7%9F%BF%E5%9C%BA%E6%90%AD%E5%BB%BA"><span class="toc-text">[HNOI2012] 矿场搭建</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HNOI2012-%E7%9F%BF%E5%9C%BA%E6%90%AD%E5%BB%BA-1"><span class="toc-text">[HNOI2012] 矿场搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F"><span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F"><span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-1"><span class="toc-text">样例 #1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-1"><span class="toc-text">样例输入 #1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-1"><span class="toc-text">样例输出 #1</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA"><span class="toc-text">提示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%A7%A3%E9%87%8A"><span class="toc-text">样例解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E5%8F%8A%E7%BA%A6%E5%AE%9A"><span class="toc-text">数据范围及约定</span></a></li></ol></li></ol></li></ol>
    </div>
    <div class="post-container">
      <div class="post-title">
        <h2 class="title">
          
        </h2>
      </div>
      <div class="post-meta">
      </div>
      <div class="post-content">
        <h1 id="HNOI2012-矿场搭建"><a href="#HNOI2012-矿场搭建" class="headerlink" title="[HNOI2012] 矿场搭建"></a>[HNOI2012] 矿场搭建</h1><h1 id="HNOI2012-矿场搭建-1"><a href="#HNOI2012-矿场搭建-1" class="headerlink" title="[HNOI2012] 矿场搭建"></a>[HNOI2012] 矿场搭建</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>煤矿工地可以看成是由隧道连接挖煤点组成的无向图。为安全起见，希望在工地发生事故时所有挖煤点的工人都能有一条出路逃到救援出口处。于是矿主决定在某些挖煤点设立救援出口，使得无论哪一个挖煤点坍塌之后，其他挖煤点的工人都有一条道路通向救援出口。</p>
<p>请写一个程序，用来计算至少需要设置几个救援出口，以及不同最少救援出口的设置方案总数。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件有若干组数据。</p>
<p>每组数据的第一行是一个正整数 $N\ (N \le 500)$，表示工地的隧道数。</p>
<p>接下来的 $N$ 行每行是用空格隔开的两个整数 $S$ 和 $T$，表示挖煤点 $S$ 与挖煤点 $T$ 由隧道直接连接。</p>
<p>输入数据以 $0$ 结尾。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每组数据，输出一行。</p>
<p>第 $i$ 行组数据以 $\verb!Case i: !$ 开始（注意大小写，$\verb!Case!$ 与 $\verb!i!$ 之间有空格，$\verb!i!$ 与 $\verb!:!$ 之间无空格，$\verb!:!$ 之后有空格）。</p>
<p>其后是用空格隔开的两个正整数，第一个正整数表示对于第 $i$ 组输入数据至少需要设置几个救援出口，第二个正整数表示对于第 $i$ 组输入数据不同最少救援出口的设置方案总数。</p>
<p>输入数据保证答案小于 $2^{64}$。输出格式参照以下输入输出样例。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><pre class="line-numbers language-none"><code class="language-none">9
1 3
4 1
3 5
1 2
2 6
1 5
6 3
1 6
3 2
6
1 2
1 3
2 4
2 5
3 6
3 7
0</code></pre>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><pre class="line-numbers language-none"><code class="language-none">Case 1: 2 4
Case 2: 4 1</code></pre>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><ul>
<li>Case 1 的四组解分别是 $(2,4)$，$(3,4)$，$(4,5)$，$(4,6)$；</li>
<li>Case 2 的一组解为 $(4,5,6,7)$。</li>
</ul>
<h3 id="数据范围及约定"><a href="#数据范围及约定" class="headerlink" title="数据范围及约定"></a>数据范围及约定</h3><p>对于每组数据，设 $m$ 为各组 $S, T$ 中最大值，则有：</p>
<ul>
<li><p>$1 \le m \le 10^3$；</p>
</li>
<li><p>各组 $S, T$ 构成的集合 $V &#x3D; [1, m] \cap \mathbb Z$。</p>
</li>
<li><p>$V$ 中任意两点连通。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;bits&#x2F;stdc++.h&gt;
#define N 11111
using namespace std;
using ll &#x3D; long long;
struct edge
&#123;
    int u, v, to;
&#125;e[N];
int n, m;
int idx, head[N];
inline void addedge(int u, int v)
&#123;
    e[idx].v &#x3D; v;
    e[idx].u &#x3D; u;
    e[idx].to &#x3D; head[u];
    head[u] &#x3D; idx++;
&#125;

int dfn[N], low[N], tidx;
bitset&lt;N&gt; cut;
void tarjan(int u, int from)
&#123;
    dfn[u] &#x3D; ++tidx;
    low[u] &#x3D; dfn[u];
    int child &#x3D; 0;
    for(int i &#x3D; head[u]; ~i; i &#x3D; e[i].to)
    &#123;
        int v &#x3D; e[i].v;
        if(!dfn[v])
        &#123;
            tarjan(v, u);
            low[u] &#x3D; min(low[u], low[v]);
            if(low[v] &gt;&#x3D; dfn[u])
            &#123;
                child++;
                if(u !&#x3D; from || child &gt; 1) cut[u] &#x3D; true;
            &#125;

        &#125;else
        &#123;
            if(v !&#x3D; from) low[u] &#x3D; min(low[u], dfn[v]);
        &#125;
    &#125;
&#125;
int grp[N], gidx;
int cnt_not_cut &#x3D; 0, cnt_cut &#x3D; 0;
void dfs(int u)
&#123;
    grp[u] &#x3D; gidx;
    cnt_not_cut++;
    for(int i &#x3D; head[u]; ~i; i &#x3D; e[i].to)
    &#123;
        int v &#x3D; e[i].v;
        if(cut[v] &amp;&amp; grp[v] !&#x3D; gidx)
        &#123;
            cnt_cut++;
            grp[v] &#x3D; gidx;
        &#125;
        if(!grp[v]) dfs(v);
    &#125;
&#125;

int cntti &#x3D; 0;
inline bool sol()
&#123;
    cin &gt;&gt; m;
    if(m &#x3D;&#x3D; 0) return false;
    memset(head, -1, sizeof head);
    memset(dfn, 0, sizeof dfn);
    memset(low, 0, sizeof low);
    memset(grp, 0, sizeof grp);
    memset(e, 0, sizeof e);
    cut.reset();
    idx &#x3D; 0, tidx &#x3D; 0, gidx &#x3D; 0;
    cnt_not_cut &#x3D; 0, cnt_cut &#x3D; 0;
    cntti++;
    n &#x3D; -1;
    for(int i &#x3D; 1; i &lt;&#x3D; m; i++)
    &#123;
        int u, v; cin &gt;&gt; u &gt;&gt; v;
        n &#x3D; max(max(u, v), n);
        addedge(u, v), addedge(v, u);
    &#125;
    for(int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        if(!dfn[i])
        &#123;
            tarjan(i, i);
        &#125;
    &#125;
&#x2F;&#x2F;    cout &lt;&lt; &quot;\n&quot;;
&#x2F;&#x2F;    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) cout &lt;&lt; cut[i] &lt;&lt; &quot; &quot;;
&#x2F;&#x2F;    cout &lt;&lt; &quot;\n&quot;;
&#x2F;&#x2F;

    ll ans &#x3D; 1, cnt &#x3D; 0;
    for(int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        if(!grp[i] &amp;&amp; !cut[i])
        &#123;
            ++gidx;
            cnt_cut &#x3D; 0;
            cnt_not_cut &#x3D; cnt_cut;
            dfs(i);
            if(cnt_cut &#x3D;&#x3D; 0)
            &#123;
                cnt +&#x3D; 2;
                ans *&#x3D; (cnt_not_cut - 1) * cnt_not_cut &#x2F; 2;
            &#125;
            if(cnt_cut &#x3D;&#x3D; 1)
            &#123;
                cnt +&#x3D; 1;
                ans *&#x3D; cnt_not_cut;
            &#125;
        &#125;
    &#125;
    cout &lt;&lt; &quot;Case &quot; &lt;&lt; cntti &lt;&lt; &quot;: &quot; &lt;&lt; cnt &lt;&lt; &quot; &quot; &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
    return true;
&#125;

int main()
&#123;
    while(sol());
    return 0;
&#125;</code></pre></li>
</ul>

      </div>
    </div>
  </section>
</article>
<!-- go-top -->
<a id="goTop" class="go-top" type="button">
  <svg t="1693380723883" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3999" width="20" height="20">
    <path d="M825.568 555.328l-287.392-289.28C531.808 259.648 523.488 256.576 515.2 256.64 514.08 256.544 513.12 256 512 256c-4.672 0-9.024 1.088-13.024 2.88-4.032 1.536-7.872 3.872-11.136 7.136l-259.328 258.88c-12.512 12.48-12.544 32.736-0.032 45.248 6.24 6.272 14.432 9.408 22.656 9.408 8.192 0 16.352-3.136 22.624-9.344L480 364.288 480 928c0 17.696 14.336 32 32 32s32-14.304 32-32L544 362.72l236.192 237.728c6.24 6.272 14.496 9.44 22.688 9.44s16.32-3.104 22.56-9.312C838.016 588.128 838.048 567.84 825.568 555.328zM864 192 160 192C142.336 192 128 177.664 128 160s14.336-32 32-32l704 0c17.696 0 32 14.336 32 32S881.696 192 864 192z" fill="#ffffff" p-id="4000"></path>
  </svg>
</a>
<script>
  goTop.addEventListener('click', function(e) {
    document.querySelector('.post-container').scrollTo({
      top: 0,
      left: 0,
      behavior: "smooth",
    });
  });
</script>
</body>

</html>